/* Generated by JTB 1.4.7 */
package msmb.parsers.chemicalReaction.visitor;

import msmb.parsers.chemicalReaction.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "Ret" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The user return information type
 */
public class DepthFirstRetVisitor<R> implements IRetVisitor<R> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeChoice n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    final R nRes = n.choice.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeList n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeListOptional n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeOptional n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      final R nRes = n.node.accept(this);
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeSequence n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeTCF n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeToken n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link CompleteReaction} node, whose children are the following :
   * <p>
   * reaction -> Reaction()<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteReaction n) {
    R nRes = null;
    // reaction -> Reaction()
    final Reaction n0 = n.reaction;
    nRes = n0.accept(this);
    // nodeToken -> <EOF>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link CompleteSpeciesWithCoefficient} node, whose children are the following :
   * <p>
   * speciesWithCoeff -> SpeciesWithCoeff()<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteSpeciesWithCoefficient n) {
    R nRes = null;
    // speciesWithCoeff -> SpeciesWithCoeff()
    final SpeciesWithCoeff n0 = n.speciesWithCoeff;
    nRes = n0.accept(this);
    // nodeToken -> <EOF>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link Reaction} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 #0 ( AdditiveExpression() )?<br>
   * .......... .. . .. #1 ( Blank() )*<br>
   * .......... .. . .. #2 <ARROW><br>
   * .......... .. . .. #3 ( ( $0 ( " " )<br>
   * .......... .. . .. .. . . $1 ( Blank() )*<br>
   * .......... .. . .. .. . . $2 ( AdditiveExpression() )? ) )?<br>
   * .......... .. . .. #4 ( $0 ( Blank() )*<br>
   * .......... .. . .. .. . $1 ";"<br>
   * .......... .. . .. .. . $2 ( Blank() )*<br>
   * .......... .. . .. .. . $3 ListModifiers() )?<br>
   * .......... .. | %1 #0 <ARROW2><br>
   * .......... .. . .. #1 ( Blank() )*<br>
   * .......... .. . .. #2 ( AdditiveExpression() )?<br>
   * .......... .. . .. #3 ( $0 ( Blank() )*<br>
   * .......... .. . .. .. . $1 ";"<br>
   * .......... .. . .. .. . $2 ( Blank() )*<br>
   * .......... .. . .. .. . $3 ListModifiers() )?<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Reaction n) {
    R nRes = null;
    // nodeChoice -> . %0 #0 ( AdditiveExpression() )?
    // .......... .. . .. #1 ( Blank() )*
    // .......... .. . .. #2 <ARROW>
    // .......... .. . .. #3 ( ( $0 ( " " )
    // .......... .. . .. .. . . $1 ( Blank() )*
    // .......... .. . .. .. . . $2 ( AdditiveExpression() )? ) )?
    // .......... .. . .. #4 ( $0 ( Blank() )*
    // .......... .. . .. .. . $1 ";"
    // .......... .. . .. .. . $2 ( Blank() )*
    // .......... .. . .. .. . $3 ListModifiers() )?
    // .......... .. | %1 #0 <ARROW2>
    // .......... .. . .. #1 ( Blank() )*
    // .......... .. . .. #2 ( AdditiveExpression() )?
    // .......... .. . .. #3 ( $0 ( Blank() )*
    // .......... .. . .. .. . $1 ";"
    // .......... .. . .. .. . $2 ( Blank() )*
    // .......... .. . .. .. . $3 ListModifiers() )?
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 #0 ( AdditiveExpression() )?
        // .. #1 ( Blank() )*
        // .. #2 <ARROW>
        // .. #3 ( ( $0 ( " " )
        // .. .. . . $1 ( Blank() )*
        // .. .. . . $2 ( AdditiveExpression() )? ) )?
        // .. #4 ( $0 ( Blank() )*
        // .. .. . $1 ";"
        // .. .. . $2 ( Blank() )*
        // .. .. . $3 ListModifiers() )?
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 ( AdditiveExpression() )?
        final INode n0CHS00A0 = n0CHS0.elementAt(0);
        final NodeOptional n0CHS00A0P = (NodeOptional) n0CHS00A0;
        if (n0CHS00A0P.present()) {
          nRes = n0CHS00A0P.accept(this);
        }
        // #1 ( Blank() )*
        final INode n0CHS0A1 = n0CHS0.elementAt(1);
        final NodeListOptional n0CHS0A1T = (NodeListOptional) n0CHS0A1;
        if (n0CHS0A1T.present()) {
          for (int i = 0; i < n0CHS0A1T.size(); i++) {
            final INode n0CHS0A1TMi = n0CHS0A1T.elementAt(i);
            nRes = n0CHS0A1TMi.accept(this);
          }
        }
        // #2 <ARROW>
        final INode n0CHS0A2 = n0CHS0.elementAt(2);
        nRes = n0CHS0A2.accept(this);
        // #3 ( ( $0 ( " " )
        // .. . . $1 ( Blank() )*
        // .. . . $2 ( AdditiveExpression() )? ) )?
        final INode n0CHS0A3 = n0CHS0.elementAt(3);
        final NodeOptional n0CHS0A3P1 = (NodeOptional) n0CHS0A3;
        if (n0CHS0A3P1.present()) {
          final NodeSequence n0CHS0A3P1S1 = (NodeSequence) n0CHS0A3P1.node;
          // $0 ( " " )
          final INode n0CHS0A3P1S1A0 = n0CHS0A3P1S1.elementAt(0);
          nRes = n0CHS0A3P1S1A0.accept(this);
          // $1 ( Blank() )*
          final INode n0CHS0A3P1S1A1 = n0CHS0A3P1S1.elementAt(1);
          final NodeListOptional n0CHS0A3P1S1A1T1 = (NodeListOptional) n0CHS0A3P1S1A1;
          if (n0CHS0A3P1S1A1T1.present()) {
            for (int i = 0; i < n0CHS0A3P1S1A1T1.size(); i++) {
              final INode n0CHS0A3P1S1A1T1Mi = n0CHS0A3P1S1A1T1.elementAt(i);
              nRes = n0CHS0A3P1S1A1T1Mi.accept(this);
            }
          }
          // $2 ( AdditiveExpression() )?
          final INode n0CHS0A3P1S1A2 = n0CHS0A3P1S1.elementAt(2);
          final NodeOptional n0CHS0A3P1S1A2P2 = (NodeOptional) n0CHS0A3P1S1A2;
          if (n0CHS0A3P1S1A2P2.present()) {
            nRes = n0CHS0A3P1S1A2P2.accept(this);
          }
        }
        // #4 ( $0 ( Blank() )*
        // .. . $1 ";"
        // .. . $2 ( Blank() )*
        // .. . $3 ListModifiers() )?
        final INode n0CHS0A4 = n0CHS0.elementAt(4);
        final NodeOptional n0CHS0A4P3 = (NodeOptional) n0CHS0A4;
        if (n0CHS0A4P3.present()) {
          final NodeSequence n0CHS0A4P3S1 = (NodeSequence) n0CHS0A4P3.node;
          // $0 ( Blank() )*
          final INode n0CHS0A4P3S1A0 = n0CHS0A4P3S1.elementAt(0);
          final NodeListOptional n0CHS0A4P3S1A0T2 = (NodeListOptional) n0CHS0A4P3S1A0;
          if (n0CHS0A4P3S1A0T2.present()) {
            for (int i = 0; i < n0CHS0A4P3S1A0T2.size(); i++) {
              final INode n0CHS0A4P3S1A0T2Mi = n0CHS0A4P3S1A0T2.elementAt(i);
              nRes = n0CHS0A4P3S1A0T2Mi.accept(this);
            }
          }
          // $1 ";"
          final INode n0CHS0A4P3S1A1 = n0CHS0A4P3S1.elementAt(1);
          nRes = n0CHS0A4P3S1A1.accept(this);
          // $2 ( Blank() )*
          final INode n0CHS0A4P3S1A2 = n0CHS0A4P3S1.elementAt(2);
          final NodeListOptional n0CHS0A4P3S1A2T3 = (NodeListOptional) n0CHS0A4P3S1A2;
          if (n0CHS0A4P3S1A2T3.present()) {
            for (int i = 0; i < n0CHS0A4P3S1A2T3.size(); i++) {
              final INode n0CHS0A4P3S1A2T3Mi = n0CHS0A4P3S1A2T3.elementAt(i);
              nRes = n0CHS0A4P3S1A2T3Mi.accept(this);
            }
          }
          // $3 ListModifiers()
          final INode n0CHS0A4P3S1A3 = n0CHS0A4P3S1.elementAt(3);
          nRes = n0CHS0A4P3S1A3.accept(this);
        }
        break;
      case 1:
        // %1 #0 <ARROW2>
        // .. #1 ( Blank() )*
        // .. #2 ( AdditiveExpression() )?
        // .. #3 ( $0 ( Blank() )*
        // .. .. . $1 ";"
        // .. .. . $2 ( Blank() )*
        // .. .. . $3 ListModifiers() )?
        final NodeSequence n0CHS1 = (NodeSequence) n0CH;
        // #0 <ARROW2>
        final INode n0CHS11A0 = n0CHS1.elementAt(0);
        nRes = n0CHS11A0.accept(this);
        // #1 ( Blank() )*
        final INode n0CHS11A1 = n0CHS1.elementAt(1);
        final NodeListOptional n0CHS11A1T4 = (NodeListOptional) n0CHS11A1;
        if (n0CHS11A1T4.present()) {
          for (int i = 0; i < n0CHS11A1T4.size(); i++) {
            final INode n0CHS11A1T4Mi = n0CHS11A1T4.elementAt(i);
            nRes = n0CHS11A1T4Mi.accept(this);
          }
        }
        // #2 ( AdditiveExpression() )?
        final INode n0CHS1A2 = n0CHS1.elementAt(2);
        final NodeOptional n0CHS1A2P4 = (NodeOptional) n0CHS1A2;
        if (n0CHS1A2P4.present()) {
          nRes = n0CHS1A2P4.accept(this);
        }
        // #3 ( $0 ( Blank() )*
        // .. . $1 ";"
        // .. . $2 ( Blank() )*
        // .. . $3 ListModifiers() )?
        final INode n0CHS1A3 = n0CHS1.elementAt(3);
        final NodeOptional n0CHS1A3P5 = (NodeOptional) n0CHS1A3;
        if (n0CHS1A3P5.present()) {
          final NodeSequence n0CHS1A3P5S2 = (NodeSequence) n0CHS1A3P5.node;
          // $0 ( Blank() )*
          final INode n0CHS1A3P5S2A0 = n0CHS1A3P5S2.elementAt(0);
          final NodeListOptional n0CHS1A3P5S2A0T5 = (NodeListOptional) n0CHS1A3P5S2A0;
          if (n0CHS1A3P5S2A0T5.present()) {
            for (int i = 0; i < n0CHS1A3P5S2A0T5.size(); i++) {
              final INode n0CHS1A3P5S2A0T5Mi = n0CHS1A3P5S2A0T5.elementAt(i);
              nRes = n0CHS1A3P5S2A0T5Mi.accept(this);
            }
          }
          // $1 ";"
          final INode n0CHS1A3P5S2A1 = n0CHS1A3P5S2.elementAt(1);
          nRes = n0CHS1A3P5S2A1.accept(this);
          // $2 ( Blank() )*
          final INode n0CHS1A3P5S2A2 = n0CHS1A3P5S2.elementAt(2);
          final NodeListOptional n0CHS1A3P5S2A2T6 = (NodeListOptional) n0CHS1A3P5S2A2;
          if (n0CHS1A3P5S2A2T6.present()) {
            for (int i = 0; i < n0CHS1A3P5S2A2T6.size(); i++) {
              final INode n0CHS1A3P5S2A2T6Mi = n0CHS1A3P5S2A2T6.elementAt(i);
              nRes = n0CHS1A3P5S2A2T6Mi.accept(this);
            }
          }
          // $3 ListModifiers()
          final INode n0CHS1A3P5S2A3 = n0CHS1A3P5S2.elementAt(3);
          nRes = n0CHS1A3P5S2A3.accept(this);
        }
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * speciesWithCoeff -> SpeciesWithCoeff()<br>
   * nodeListOptional -> ( #0 ( Blank() )*<br>
   * ................ .. . #1 " + "<br>
   * ................ .. . #2 ( Blank() )*<br>
   * ................ .. . #3 SpeciesWithCoeff() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final AdditiveExpression n) {
    R nRes = null;
    // speciesWithCoeff -> SpeciesWithCoeff()
    final SpeciesWithCoeff n0 = n.speciesWithCoeff;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 ( Blank() )*
    // ................ .. . #1 " + "
    // ................ .. . #2 ( Blank() )*
    // ................ .. . #3 SpeciesWithCoeff() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 ( Blank() )*
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        final NodeListOptional n1MiS0A0T = (NodeListOptional) n1MiS0A0;
        if (n1MiS0A0T.present()) {
          for (int i1 = 0; i1 < n1MiS0A0T.size(); i1++) {
            final INode n1MiS0A0TMi = n1MiS0A0T.elementAt(i1);
            nRes = n1MiS0A0TMi.accept(this);
          }
        }
        // #1 " + "
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
        // #2 ( Blank() )*
        final INode n1MiS0A2 = n1MiS0.elementAt(2);
        final NodeListOptional n1MiS0A2T1 = (NodeListOptional) n1MiS0A2;
        if (n1MiS0A2T1.present()) {
          for (int i1 = 0; i1 < n1MiS0A2T1.size(); i1++) {
            final INode n1MiS0A2T1Mi = n1MiS0A2T1.elementAt(i1);
            nRes = n1MiS0A2T1Mi.accept(this);
          }
        }
        // #3 SpeciesWithCoeff()
        final INode n1MiS0A3 = n1MiS0.elementAt(3);
        nRes = n1MiS0A3.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link SpeciesWithCoeff} node, whose children are the following :
   * <p>
   * nodeOptional -> ( #0 Stoichiometry()<br>
   * ............ .. . #1 ( Blank() )*<br>
   * ............ .. . #2 " * "<br>
   * ............ .. . #3 ( Blank() )* )?<br>
   * species -> Species()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final SpeciesWithCoeff n) {
    R nRes = null;
    // nodeOptional -> ( #0 Stoichiometry()
    // ............ .. . #1 ( Blank() )*
    // ............ .. . #2 " * "
    // ............ .. . #3 ( Blank() )* )?
    final NodeOptional n0 = n.nodeOptional;
    if (n0.present()) {
      final NodeSequence n0S0 = (NodeSequence) n0.node;
      // #0 Stoichiometry()
      final INode n0S0A0 = n0S0.elementAt(0);
      nRes = n0S0A0.accept(this);
      // #1 ( Blank() )*
      final INode n0S0A1 = n0S0.elementAt(1);
      final NodeListOptional n0S0A1T = (NodeListOptional) n0S0A1;
      if (n0S0A1T.present()) {
        for (int i = 0; i < n0S0A1T.size(); i++) {
          final INode n0S0A1TMi = n0S0A1T.elementAt(i);
          nRes = n0S0A1TMi.accept(this);
        }
      }
      // #2 " * "
      final INode n0S0A2 = n0S0.elementAt(2);
      nRes = n0S0A2.accept(this);
      // #3 ( Blank() )*
      final INode n0S0A3 = n0S0.elementAt(3);
      final NodeListOptional n0S0A3T1 = (NodeListOptional) n0S0A3;
      if (n0S0A3T1.present()) {
        for (int i = 0; i < n0S0A3T1.size(); i++) {
          final INode n0S0A3T1Mi = n0S0A3T1.elementAt(i);
          nRes = n0S0A3T1Mi.accept(this);
        }
      }
    }
    // species -> Species()
    final Species n1 = n.species;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link Blank} node, whose children are the following :
   * <p>
   * nodeToken -> " "<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Blank n) {
    R nRes = null;
    // nodeToken -> " "
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link ListModifiers} node, whose children are the following :
   * <p>
   * species -> Species()<br>
   * nodeListOptional -> ( #0 ( Blank() )+<br>
   * ................ .. . #1 Species() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final ListModifiers n) {
    R nRes = null;
    // species -> Species()
    final Species n0 = n.species;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 ( Blank() )+
    // ................ .. . #1 Species() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 ( Blank() )+
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        final NodeList n1MiS0A0L = (NodeList) n1MiS0A0;
        for (int i1 = 0; i1 < n1MiS0A0L.size(); i1++) {
          final INode n1MiS0A0LEi = n1MiS0A0L.elementAt(i1);
          nRes = n1MiS0A0LEi.accept(this);
        }
        // #1 Species()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Species} node, whose children are the following :
   * <p>
   * nodeToken -> <IDENTIFIER><br>
   * nodeListOptional -> ( <IDENTIFIER> )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Species n) {
    R nRes = null;
    // nodeToken -> <IDENTIFIER>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeListOptional -> ( <IDENTIFIER> )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        nRes = n1Mi.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Stoichiometry} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 <INTEGER_LITERAL><br>
   * .......... .. | %1 <FLOATING_POINT_LITERAL><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Stoichiometry n) {
    R nRes = null;
    // nodeChoice -> . %0 <INTEGER_LITERAL>
    // .......... .. | %1 <FLOATING_POINT_LITERAL>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 <INTEGER_LITERAL>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 <FLOATING_POINT_LITERAL>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

}
