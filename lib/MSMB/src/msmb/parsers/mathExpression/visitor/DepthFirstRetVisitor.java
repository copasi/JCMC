/* Generated by JTB 1.4.7 */
package msmb.parsers.mathExpression.visitor;

import msmb.parsers.mathExpression.syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "Ret" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The user return information type
 */
public class DepthFirstRetVisitor<R> implements IRetVisitor<R> {


  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeChoice n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    final R nRes = n.choice.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeList n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      final R sRes = e.next().accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeListOptional n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (final Iterator<INode> e = n.elements(); e.hasNext();) {
        @SuppressWarnings("unused")
        R sRes = e.next().accept(this);
        }
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeOptional n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      final R nRes = n.node.accept(this);
      return nRes;
    } else
      return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeSequence n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (final Iterator<INode> e = n.elements(); e.hasNext();) {
      @SuppressWarnings("unused")
      R subRet = e.next().accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeTCF} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeTCF n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final NodeToken n) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link CompleteExpression} node, whose children are the following :
   * <p>
   * expression -> Expression()<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteExpression n) {
    R nRes = null;
    // expression -> Expression()
    final Expression n0 = n.expression;
    nRes = n0.accept(this);
    // nodeToken -> <EOF>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link CompleteListOfExpression} node, whose children are the following :
   * <p>
   * expression -> Expression()<br>
   * nodeListOptional -> ( #0 <COMMA> #1 Expression() )*<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteListOfExpression n) {
    R nRes = null;
    // expression -> Expression()
    final Expression n0 = n.expression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 <COMMA> #1 Expression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 <COMMA>
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        nRes = n1MiS0A0.accept(this);
        // #1 Expression()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    // nodeToken -> <EOF>
    final NodeToken n2 = n.nodeToken;
    nRes = n2.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link CompleteListOfExpression_Events} node, whose children are the following :
   * <p>
   * expression -> Expression()<br>
   * nodeListOptional -> ( #0 <SEMICOLON> #1 Expression() )*<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteListOfExpression_Events n) {
    R nRes = null;
    // expression -> Expression()
    final Expression n0 = n.expression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 <SEMICOLON> #1 Expression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 <SEMICOLON>
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        nRes = n1MiS0A0.accept(this);
        // #1 Expression()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    // nodeToken -> <EOF>
    final NodeToken n2 = n.nodeToken;
    nRes = n2.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link SingleFunctionCall} node, whose children are the following :
   * <p>
   * name -> Name()<br>
   * nodeToken -> <LPAREN><br>
   * nodeOptional -> ( ArgumentList() )?<br>
   * nodeToken1 -> <RPAREN><br>
   * nodeToken2 -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final SingleFunctionCall n) {
    R nRes = null;
    // name -> Name()
    final Name n0 = n.name;
    nRes = n0.accept(this);
    // nodeToken -> <LPAREN>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    // nodeOptional -> ( ArgumentList() )?
    final NodeOptional n2 = n.nodeOptional;
    if (n2.present()) {
      nRes = n2.accept(this);
    }
    // nodeToken1 -> <RPAREN>
    final NodeToken n3 = n.nodeToken1;
    nRes = n3.accept(this);
    // nodeToken2 -> <EOF>
    final NodeToken n4 = n.nodeToken2;
    nRes = n4.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link CompleteFunctionDeclaration} node, whose children are the following :
   * <p>
   * functionDeclarator -> FunctionDeclarator()<br>
   * nodeToken -> <EOF><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CompleteFunctionDeclaration n) {
    R nRes = null;
    // functionDeclarator -> FunctionDeclarator()
    final FunctionDeclarator n0 = n.functionDeclarator;
    nRes = n0.accept(this);
    // nodeToken -> <EOF>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link FunctionDeclarator} node, whose children are the following :
   * <p>
   * nodeToken -> <IDENTIFIER><br>
   * nodeOptional -> ( FormalParameters() )?<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final FunctionDeclarator n) {
    R nRes = null;
    // nodeToken -> <IDENTIFIER>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeOptional -> ( FormalParameters() )?
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      nRes = n1.accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link FormalParameters} node, whose children are the following :
   * <p>
   * nodeToken -> "("<br>
   * nodeOptional -> [ #0 FormalParameter()<br>
   * ............ .. . #1 ( $0 "," $1 FormalParameter() )* ]<br>
   * nodeToken1 -> ")"<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final FormalParameters n) {
    R nRes = null;
    // nodeToken -> "("
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeOptional -> [ #0 FormalParameter()
    // ............ .. . #1 ( $0 "," $1 FormalParameter() )* ]
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      final NodeSequence n1S0 = (NodeSequence) n1.node;
      // #0 FormalParameter()
      final INode n1S0A0 = n1S0.elementAt(0);
      nRes = n1S0A0.accept(this);
      // #1 ( $0 "," $1 FormalParameter() )*
      final INode n1S0A1 = n1S0.elementAt(1);
      final NodeListOptional n1S0A1T = (NodeListOptional) n1S0A1;
      if (n1S0A1T.present()) {
        for (int i = 0; i < n1S0A1T.size(); i++) {
          final INode n1S0A1TMi = n1S0A1T.elementAt(i);
          final NodeSequence n1S0A1TMiS1 = (NodeSequence) n1S0A1TMi;
          // $0 ","
          final INode n1S0A1TMiS1A0 = n1S0A1TMiS1.elementAt(0);
          nRes = n1S0A1TMiS1A0.accept(this);
          // $1 FormalParameter()
          final INode n1S0A1TMiS1A1 = n1S0A1TMiS1.elementAt(1);
          nRes = n1S0A1TMiS1A1.accept(this);
        }
      }
    }
    // nodeToken1 -> ")"
    final NodeToken n2 = n.nodeToken1;
    nRes = n2.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link FormalParameter} node, whose children are the following :
   * <p>
   * primitiveType -> PrimitiveType()<br>
   * variableDeclaratorId -> VariableDeclaratorId()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final FormalParameter n) {
    R nRes = null;
    // primitiveType -> PrimitiveType()
    final PrimitiveType n0 = n.primitiveType;
    nRes = n0.accept(this);
    // variableDeclaratorId -> VariableDeclaratorId()
    final VariableDeclaratorId n1 = n.variableDeclaratorId;
    nRes = n1.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link PrimitiveType} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 <TYPE_PAR><br>
   * .......... .. | %1 <TYPE_VAR><br>
   * .......... .. | %2 <TYPE_SUB><br>
   * .......... .. | %3 <TYPE_PROD><br>
   * .......... .. | %4 <TYPE_MOD><br>
   * .......... .. | %5 <TYPE_SITE><br>
   * .......... .. | %6 <TYPE_VOL><br>
   * .......... .. | %7 <TYPE_TIME><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final PrimitiveType n) {
    R nRes = null;
    // nodeChoice -> . %0 <TYPE_PAR>
    // .......... .. | %1 <TYPE_VAR>
    // .......... .. | %2 <TYPE_SUB>
    // .......... .. | %3 <TYPE_PROD>
    // .......... .. | %4 <TYPE_MOD>
    // .......... .. | %5 <TYPE_SITE>
    // .......... .. | %6 <TYPE_VOL>
    // .......... .. | %7 <TYPE_TIME>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 <TYPE_PAR>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 <TYPE_VAR>
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %2 <TYPE_SUB>
        nRes = n0CH.accept(this);
        break;
      case 3:
        // %3 <TYPE_PROD>
        nRes = n0CH.accept(this);
        break;
      case 4:
        // %4 <TYPE_MOD>
        nRes = n0CH.accept(this);
        break;
      case 5:
        // %5 <TYPE_SITE>
        nRes = n0CH.accept(this);
        break;
      case 6:
        // %6 <TYPE_VOL>
        nRes = n0CH.accept(this);
        break;
      case 7:
        // %7 <TYPE_TIME>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link VariableDeclaratorId} node, whose children are the following :
   * <p>
   * nodeToken -> <IDENTIFIER><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final VariableDeclaratorId n) {
    R nRes = null;
    // nodeToken -> <IDENTIFIER>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link IfExpression} node, whose children are the following :
   * <p>
   * nodeToken -> <IF><br>
   * nodeToken1 -> <LPAREN><br>
   * expression -> Expression()<br>
   * nodeToken2 -> <COMMA><br>
   * expression1 -> Expression()<br>
   * nodeOptional -> ( #0 <COMMA> #1 Expression() )?<br>
   * nodeToken3 -> <RPAREN><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final IfExpression n) {
    R nRes = null;
    // nodeToken -> <IF>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeToken1 -> <LPAREN>
    final NodeToken n1 = n.nodeToken1;
    nRes = n1.accept(this);
    // expression -> Expression()
    final Expression n2 = n.expression;
    nRes = n2.accept(this);
    // nodeToken2 -> <COMMA>
    final NodeToken n3 = n.nodeToken2;
    nRes = n3.accept(this);
    // expression1 -> Expression()
    final Expression n4 = n.expression1;
    nRes = n4.accept(this);
    // nodeOptional -> ( #0 <COMMA> #1 Expression() )?
    final NodeOptional n5 = n.nodeOptional;
    if (n5.present()) {
      final NodeSequence n5S0 = (NodeSequence) n5.node;
      // #0 <COMMA>
      final INode n5S0A0 = n5S0.elementAt(0);
      nRes = n5S0A0.accept(this);
      // #1 Expression()
      final INode n5S0A1 = n5S0.elementAt(1);
      nRes = n5S0A1.accept(this);
    }
    // nodeToken3 -> <RPAREN>
    final NodeToken n6 = n.nodeToken3;
    nRes = n6.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link LeftExpression} node, whose children are the following :
   * <p>
   * additiveExpression -> AdditiveExpression()<br>
   * nodeOptional -> ( #0 RelationalOperator() #1 Expression() )?<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final LeftExpression n) {
    R nRes = null;
    // additiveExpression -> AdditiveExpression()
    final AdditiveExpression n0 = n.additiveExpression;
    nRes = n0.accept(this);
    // nodeOptional -> ( #0 RelationalOperator() #1 Expression() )?
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      final NodeSequence n1S0 = (NodeSequence) n1.node;
      // #0 RelationalOperator()
      final INode n1S0A0 = n1S0.elementAt(0);
      nRes = n1S0A0.accept(this);
      // #1 Expression()
      final INode n1S0A1 = n1S0.elementAt(1);
      nRes = n1S0A1.accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link Expression} node, whose children are the following :
   * <p>
   * leftExpression -> LeftExpression()<br>
   * nodeListOptional -> ( #0 LogicalOperator() #1 Expression() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Expression n) {
    R nRes = null;
    // leftExpression -> LeftExpression()
    final LeftExpression n0 = n.leftExpression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 LogicalOperator() #1 Expression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 LogicalOperator()
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        nRes = n1MiS0A0.accept(this);
        // #1 Expression()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link RelationalOperator} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 ( &0 <ASSIGN><br>
   * .......... .. . .. | &1 <EQ> )<br>
   * .......... .. | %1 <LT><br>
   * .......... .. | %2 <GT><br>
   * .......... .. | %3 <GEQ><br>
   * .......... .. | %4 <LEQ><br>
   * .......... .. | %5 <NE><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final RelationalOperator n) {
    R nRes = null;
    // nodeChoice -> . %0 ( &0 <ASSIGN>
    // .......... .. . .. | &1 <EQ> )
    // .......... .. | %1 <LT>
    // .......... .. | %2 <GT>
    // .......... .. | %3 <GEQ>
    // .......... .. | %4 <LEQ>
    // .......... .. | %5 <NE>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 ( &0 <ASSIGN>
        // .. | &1 <EQ> )
        final NodeChoice n0CHC = (NodeChoice) n0CH;
        final INode n0CHCH = n0CHC.choice;
        switch (n0CHC.which) {
          case 0:
            // &0 <ASSIGN>
            nRes = n0CHCH.accept(this);
            break;
          case 1:
            // &1 <EQ>
            nRes = n0CHCH.accept(this);
            break;
          default:
            // should not occur !!!
            break;
        }
        break;
      case 1:
        // %1 <LT>
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %2 <GT>
        nRes = n0CH.accept(this);
        break;
      case 3:
        // %3 <GEQ>
        nRes = n0CH.accept(this);
        break;
      case 4:
        // %4 <LEQ>
        nRes = n0CH.accept(this);
        break;
      case 5:
        // %5 <NE>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link LogicalOperator} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 <AND><br>
   * .......... .. | %1 <OR><br>
   * .......... .. | %2 <XOR><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final LogicalOperator n) {
    R nRes = null;
    // nodeChoice -> . %0 <AND>
    // .......... .. | %1 <OR>
    // .......... .. | %2 <XOR>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 <AND>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 <OR>
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %2 <XOR>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link AdditiveExpression} node, whose children are the following :
   * <p>
   * multiplicativeExpression -> MultiplicativeExpression()<br>
   * nodeListOptional -> ( #0 ( %0 <PLUS><br>
   * ................ .. . .. | %1 <MINUS> )<br>
   * ................ .. . #1 MultiplicativeExpression() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final AdditiveExpression n) {
    R nRes = null;
    // multiplicativeExpression -> MultiplicativeExpression()
    final MultiplicativeExpression n0 = n.multiplicativeExpression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 ( %0 <PLUS>
    // ................ .. . .. | %1 <MINUS> )
    // ................ .. . #1 MultiplicativeExpression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 ( %0 <PLUS>
        // .. | %1 <MINUS> )
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        final NodeChoice n1MiS0A0C = (NodeChoice) n1MiS0A0;
        final INode n1MiS0A0CH = n1MiS0A0C.choice;
        switch (n1MiS0A0C.which) {
          case 0:
            // %0 <PLUS>
            nRes = n1MiS0A0CH.accept(this);
            break;
          case 1:
            // %1 <MINUS>
            nRes = n1MiS0A0CH.accept(this);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #1 MultiplicativeExpression()
        final INode n1MiS01A1 = n1MiS0.elementAt(1);
        nRes = n1MiS01A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link MultiplicativeExpression} node, whose children are the following :
   * <p>
   * powerExpression -> PowerExpression()<br>
   * nodeListOptional -> ( #0 ( %0 <TIMES><br>
   * ................ .. . .. | %1 <DIV> )<br>
   * ................ .. . #1 PowerExpression() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final MultiplicativeExpression n) {
    R nRes = null;
    // powerExpression -> PowerExpression()
    final PowerExpression n0 = n.powerExpression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 ( %0 <TIMES>
    // ................ .. . .. | %1 <DIV> )
    // ................ .. . #1 PowerExpression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 ( %0 <TIMES>
        // .. | %1 <DIV> )
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        final NodeChoice n1MiS0A0C = (NodeChoice) n1MiS0A0;
        final INode n1MiS0A0CH = n1MiS0A0C.choice;
        switch (n1MiS0A0C.which) {
          case 0:
            // %0 <TIMES>
            nRes = n1MiS0A0CH.accept(this);
            break;
          case 1:
            // %1 <DIV>
            nRes = n1MiS0A0CH.accept(this);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #1 PowerExpression()
        final INode n1MiS01A1 = n1MiS0.elementAt(1);
        nRes = n1MiS01A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link PowerExpression} node, whose children are the following :
   * <p>
   * unaryExpression -> UnaryExpression()<br>
   * nodeListOptional -> ( #0 ( <CARET> )<br>
   * ................ .. . #1 UnaryExpression() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final PowerExpression n) {
    R nRes = null;
    // unaryExpression -> UnaryExpression()
    final UnaryExpression n0 = n.unaryExpression;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 ( <CARET> )
    // ................ .. . #1 UnaryExpression() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 ( <CARET> )
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        nRes = n1MiS0A0.accept(this);
        // #1 UnaryExpression()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link UnaryExpression} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 #0 ( &0 <PLUS><br>
   * .......... .. . .. .. | &1 <MINUS> )<br>
   * .......... .. . .. #1 UnaryExpression()<br>
   * .......... .. | %1 UnaryExpressionNotPlusMinus()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final UnaryExpression n) {
    R nRes = null;
    // nodeChoice -> . %0 #0 ( &0 <PLUS>
    // .......... .. . .. .. | &1 <MINUS> )
    // .......... .. . .. #1 UnaryExpression()
    // .......... .. | %1 UnaryExpressionNotPlusMinus()
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 #0 ( &0 <PLUS>
        // .. .. | &1 <MINUS> )
        // .. #1 UnaryExpression()
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 ( &0 <PLUS>
        // .. | &1 <MINUS> )
        final INode n0CHS00A0 = n0CHS0.elementAt(0);
        final NodeChoice n0CHS00A0C = (NodeChoice) n0CHS00A0;
        final INode n0CHS00A0CH = n0CHS00A0C.choice;
        switch (n0CHS00A0C.which) {
          case 0:
            // &0 <PLUS>
            nRes = n0CHS00A0CH.accept(this);
            break;
          case 1:
            // &1 <MINUS>
            nRes = n0CHS00A0CH.accept(this);
            break;
          default:
            // should not occur !!!
            break;
        }
        // #1 UnaryExpression()
        final INode n0CHS01A1 = n0CHS0.elementAt(1);
        nRes = n0CHS01A1.accept(this);
        break;
      case 1:
        // %1 UnaryExpressionNotPlusMinus()
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link UnaryExpressionNotPlusMinus} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 #0 <BANG> #1 UnaryExpression()<br>
   * .......... .. | %1 PrimaryExpression()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final UnaryExpressionNotPlusMinus n) {
    R nRes = null;
    // nodeChoice -> . %0 #0 <BANG> #1 UnaryExpression()
    // .......... .. | %1 PrimaryExpression()
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 #0 <BANG> #1 UnaryExpression()
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 <BANG>
        final INode n0CHS00A0 = n0CHS0.elementAt(0);
        nRes = n0CHS00A0.accept(this);
        // #1 UnaryExpression()
        final INode n0CHS00A1 = n0CHS0.elementAt(1);
        nRes = n0CHS00A1.accept(this);
        break;
      case 1:
        // %1 PrimaryExpression()
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link PrimaryExpression} node, whose children are the following :
   * <p>
   * primaryPrefix -> PrimaryPrefix()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final PrimaryExpression n) {
    R nRes = null;
    // primaryPrefix -> PrimaryPrefix()
    final PrimaryPrefix n0 = n.primaryPrefix;
    nRes = n0.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link PrimaryPrefix} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 Literal()<br>
   * .......... .. | %1 #0 <LPAREN> #1 Expression() #2 <RPAREN><br>
   * .......... .. | %2 SpeciesReferenceOrFunctionCall()<br>
   * .......... .. | %3 MultistateSum()<br>
   * .......... .. | %4 IfExpression()<br>
   * .......... .. | %5 <CONST_MODEL_TIME><br>
   * .......... .. | %6 <CONST_QUANTITY_CONV_FACTOR><br>
   * .......... .. | %7 <CONST_MODEL_TIME_INITIAL><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final PrimaryPrefix n) {
    R nRes = null;
    // nodeChoice -> . %0 Literal()
    // .......... .. | %1 #0 <LPAREN> #1 Expression() #2 <RPAREN>
    // .......... .. | %2 SpeciesReferenceOrFunctionCall()
    // .......... .. | %3 MultistateSum()
    // .......... .. | %4 IfExpression()
    // .......... .. | %5 <CONST_MODEL_TIME>
    // .......... .. | %6 <CONST_QUANTITY_CONV_FACTOR>
    // .......... .. | %7 <CONST_MODEL_TIME_INITIAL>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 Literal()
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 #0 <LPAREN> #1 Expression() #2 <RPAREN>
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 <LPAREN>
        final INode n0CHS01A0 = n0CHS0.elementAt(0);
        nRes = n0CHS01A0.accept(this);
        // #1 Expression()
        final INode n0CHS01A1 = n0CHS0.elementAt(1);
        nRes = n0CHS01A1.accept(this);
        // #2 <RPAREN>
        final INode n0CHS01A2 = n0CHS0.elementAt(2);
        nRes = n0CHS01A2.accept(this);
        break;
      case 2:
        // %2 SpeciesReferenceOrFunctionCall()
        nRes = n0CH.accept(this);
        break;
      case 3:
        // %3 MultistateSum()
        nRes = n0CH.accept(this);
        break;
      case 4:
        // %4 IfExpression()
        nRes = n0CH.accept(this);
        break;
      case 5:
        // %5 <CONST_MODEL_TIME>
        nRes = n0CH.accept(this);
        break;
      case 6:
        // %6 <CONST_QUANTITY_CONV_FACTOR>
        nRes = n0CH.accept(this);
        break;
      case 7:
        // %7 <CONST_MODEL_TIME_INITIAL>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link MultistateSum} node, whose children are the following :
   * <p>
   * nodeToken -> <SUM><br>
   * nodeToken1 -> <LPAREN><br>
   * argumentList_MultistateSum -> ArgumentList_MultistateSum()<br>
   * nodeToken2 -> <RPAREN><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final MultistateSum n) {
    R nRes = null;
    // nodeToken -> <SUM>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeToken1 -> <LPAREN>
    final NodeToken n1 = n.nodeToken1;
    nRes = n1.accept(this);
    // argumentList_MultistateSum -> ArgumentList_MultistateSum()
    final ArgumentList_MultistateSum n2 = n.argumentList_MultistateSum;
    nRes = n2.accept(this);
    // nodeToken2 -> <RPAREN>
    final NodeToken n3 = n.nodeToken2;
    nRes = n3.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link Name} node, whose children are the following :
   * <p>
   * nodeChoice -> . %00 <IDENTIFIER><br>
   * .......... .. | %01 PrimitiveType()<br>
   * .......... .. | %02 <PI><br>
   * .......... .. | %03 <EXPONENTIALE><br>
   * .......... .. | %04 <CONST_AVOGADRO><br>
   * .......... .. | %05 <TIME><br>
   * .......... .. | %06 <FLOOR><br>
   * .......... .. | %07 <DELAY><br>
   * .......... .. | %08 <CEIL><br>
   * .......... .. | %09 <FACTORIAL><br>
   * .......... .. | %10 <ASIN><br>
   * .......... .. | %11 <ACOS><br>
   * .......... .. | %12 <ATAN><br>
   * .......... .. | %13 <TAN><br>
   * .......... .. | %14 <TANH><br>
   * .......... .. | %15 <COSH><br>
   * .......... .. | %16 <LOG10><br>
   * .......... .. | %17 <ABS><br>
   * .......... .. | %18 <COS><br>
   * .......... .. | %19 <SIN><br>
   * .......... .. | %20 <SEC><br>
   * .......... .. | %21 <CSC><br>
   * .......... .. | %22 <COT><br>
   * .......... .. | %23 <SINH><br>
   * .......... .. | %24 <ARCSEC><br>
   * .......... .. | %25 <ARCCSC><br>
   * .......... .. | %26 <ARCCOT><br>
   * .......... .. | %27 <ARCSINH><br>
   * .......... .. | %28 <ARCCOSH><br>
   * .......... .. | %29 <ARCTANH><br>
   * .......... .. | %30 <ARCSECH><br>
   * .......... .. | %31 <ARCCSCH><br>
   * .......... .. | %32 <ARCCOTH><br>
   * .......... .. | %33 <MIN><br>
   * .......... .. | %34 <MAX><br>
   * .......... .. | %35 <LOG><br>
   * .......... .. | %36 <EXP><br>
   * .......... .. | %37 <NAN1><br>
   * .......... .. | %38 <NAN2><br>
   * .......... .. | %39 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Name n) {
    R nRes = null;
    // nodeChoice -> . %00 <IDENTIFIER>
    // .......... .. | %01 PrimitiveType()
    // .......... .. | %02 <PI>
    // .......... .. | %03 <EXPONENTIALE>
    // .......... .. | %04 <CONST_AVOGADRO>
    // .......... .. | %05 <TIME>
    // .......... .. | %06 <FLOOR>
    // .......... .. | %07 <DELAY>
    // .......... .. | %08 <CEIL>
    // .......... .. | %09 <FACTORIAL>
    // .......... .. | %10 <ASIN>
    // .......... .. | %11 <ACOS>
    // .......... .. | %12 <ATAN>
    // .......... .. | %13 <TAN>
    // .......... .. | %14 <TANH>
    // .......... .. | %15 <COSH>
    // .......... .. | %16 <LOG10>
    // .......... .. | %17 <ABS>
    // .......... .. | %18 <COS>
    // .......... .. | %19 <SIN>
    // .......... .. | %20 <SEC>
    // .......... .. | %21 <CSC>
    // .......... .. | %22 <COT>
    // .......... .. | %23 <SINH>
    // .......... .. | %24 <ARCSEC>
    // .......... .. | %25 <ARCCSC>
    // .......... .. | %26 <ARCCOT>
    // .......... .. | %27 <ARCSINH>
    // .......... .. | %28 <ARCCOSH>
    // .......... .. | %29 <ARCTANH>
    // .......... .. | %30 <ARCSECH>
    // .......... .. | %31 <ARCCSCH>
    // .......... .. | %32 <ARCCOTH>
    // .......... .. | %33 <MIN>
    // .......... .. | %34 <MAX>
    // .......... .. | %35 <LOG>
    // .......... .. | %36 <EXP>
    // .......... .. | %37 <NAN1>
    // .......... .. | %38 <NAN2>
    // .......... .. | %39 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %00 <IDENTIFIER>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %01 PrimitiveType()
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %02 <PI>
        nRes = n0CH.accept(this);
        break;
      case 3:
        // %03 <EXPONENTIALE>
        nRes = n0CH.accept(this);
        break;
      case 4:
        // %04 <CONST_AVOGADRO>
        nRes = n0CH.accept(this);
        break;
      case 5:
        // %05 <TIME>
        nRes = n0CH.accept(this);
        break;
      case 6:
        // %06 <FLOOR>
        nRes = n0CH.accept(this);
        break;
      case 7:
        // %07 <DELAY>
        nRes = n0CH.accept(this);
        break;
      case 8:
        // %08 <CEIL>
        nRes = n0CH.accept(this);
        break;
      case 9:
        // %09 <FACTORIAL>
        nRes = n0CH.accept(this);
        break;
      case 10:
        // %10 <ASIN>
        nRes = n0CH.accept(this);
        break;
      case 11:
        // %11 <ACOS>
        nRes = n0CH.accept(this);
        break;
      case 12:
        // %12 <ATAN>
        nRes = n0CH.accept(this);
        break;
      case 13:
        // %13 <TAN>
        nRes = n0CH.accept(this);
        break;
      case 14:
        // %14 <TANH>
        nRes = n0CH.accept(this);
        break;
      case 15:
        // %15 <COSH>
        nRes = n0CH.accept(this);
        break;
      case 16:
        // %16 <LOG10>
        nRes = n0CH.accept(this);
        break;
      case 17:
        // %17 <ABS>
        nRes = n0CH.accept(this);
        break;
      case 18:
        // %18 <COS>
        nRes = n0CH.accept(this);
        break;
      case 19:
        // %19 <SIN>
        nRes = n0CH.accept(this);
        break;
      case 20:
        // %20 <SEC>
        nRes = n0CH.accept(this);
        break;
      case 21:
        // %21 <CSC>
        nRes = n0CH.accept(this);
        break;
      case 22:
        // %22 <COT>
        nRes = n0CH.accept(this);
        break;
      case 23:
        // %23 <SINH>
        nRes = n0CH.accept(this);
        break;
      case 24:
        // %24 <ARCSEC>
        nRes = n0CH.accept(this);
        break;
      case 25:
        // %25 <ARCCSC>
        nRes = n0CH.accept(this);
        break;
      case 26:
        // %26 <ARCCOT>
        nRes = n0CH.accept(this);
        break;
      case 27:
        // %27 <ARCSINH>
        nRes = n0CH.accept(this);
        break;
      case 28:
        // %28 <ARCCOSH>
        nRes = n0CH.accept(this);
        break;
      case 29:
        // %29 <ARCTANH>
        nRes = n0CH.accept(this);
        break;
      case 30:
        // %30 <ARCSECH>
        nRes = n0CH.accept(this);
        break;
      case 31:
        // %31 <ARCCSCH>
        nRes = n0CH.accept(this);
        break;
      case 32:
        // %32 <ARCCOTH>
        nRes = n0CH.accept(this);
        break;
      case 33:
        // %33 <MIN>
        nRes = n0CH.accept(this);
        break;
      case 34:
        // %34 <MAX>
        nRes = n0CH.accept(this);
        break;
      case 35:
        // %35 <LOG>
        nRes = n0CH.accept(this);
        break;
      case 36:
        // %36 <EXP>
        nRes = n0CH.accept(this);
        break;
      case 37:
        // %37 <NAN1>
        nRes = n0CH.accept(this);
        break;
      case 38:
        // %38 <NAN2>
        nRes = n0CH.accept(this);
        break;
      case 39:
        // %39 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER>
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 <MUTANT_PARENT_SEPARATOR>
        final INode n0CHS039A0 = n0CHS0.elementAt(0);
        nRes = n0CHS039A0.accept(this);
        // #1 <IDENTIFIER>
        final INode n0CHS039A1 = n0CHS0.elementAt(1);
        nRes = n0CHS039A1.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link SpeciesReferenceOrFunctionCall_prefix} node, whose children are the following :
   * <p>
   * name -> Name()<br>
   * nodeOptional -> [ #0 <LPAREN><br>
   * ............ .. . #1 [ ArgumentList() ]<br>
   * ............ .. . #2 <RPAREN> ]<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final SpeciesReferenceOrFunctionCall_prefix n) {
    R nRes = null;
    // name -> Name()
    final Name n0 = n.name;
    nRes = n0.accept(this);
    // nodeOptional -> [ #0 <LPAREN>
    // ............ .. . #1 [ ArgumentList() ]
    // ............ .. . #2 <RPAREN> ]
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      final NodeSequence n1S0 = (NodeSequence) n1.node;
      // #0 <LPAREN>
      final INode n1S0A0 = n1S0.elementAt(0);
      nRes = n1S0A0.accept(this);
      // #1 [ ArgumentList() ]
      final INode n1S0A1 = n1S0.elementAt(1);
      final NodeOptional n1S0A1P = (NodeOptional) n1S0A1;
      if (n1S0A1P.present()) {
        nRes = n1S0A1P.accept(this);
      }
      // #2 <RPAREN>
      final INode n1S0A2 = n1S0.elementAt(2);
      nRes = n1S0A2.accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link SpeciesReferenceOrFunctionCall} node, whose children are the following :
   * <p>
   * speciesReferenceOrFunctionCall_prefix -> SpeciesReferenceOrFunctionCall_prefix()<br>
   * nodeListOptional -> ( ( PossibleExtensions() ) )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final SpeciesReferenceOrFunctionCall n) {
    R nRes = null;
    // speciesReferenceOrFunctionCall_prefix -> SpeciesReferenceOrFunctionCall_prefix()
    final SpeciesReferenceOrFunctionCall_prefix n0 = n.speciesReferenceOrFunctionCall_prefix;
    nRes = n0.accept(this);
    // nodeListOptional -> ( ( PossibleExtensions() ) )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        nRes = n1Mi.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link PossibleExtensions} node, whose children are the following :
   * <p>
   * nodeChoice -> ( %00 <EXTENSION_CONC><br>
   * .......... .. | %01 <EXTENSION_COMPARTMENT><br>
   * .......... .. | %02 <EXTENSION_PARTICLE><br>
   * .......... .. | %03 <EXTENSION_TRANS><br>
   * .......... .. | %04 <EXTENSION_INIT><br>
   * .......... .. | %05 <EXTENSION_RATE><br>
   * .......... .. | %06 <EXTENSION_SPECIES><br>
   * .......... .. | %07 <EXTENSION_GLOBALQ><br>
   * .......... .. | %08 <EXTENSION_FUNCTION><br>
   * .......... .. | %09 <EXTENSION_REACTION><br>
   * .......... .. | %10 <EXTENSION_FLUX><br>
   * .......... .. | %11 <MY_SPECIAL_EXTENSION><br>
   * .......... .. | %12 #0 "." #1 <IDENTIFIER><br>
   * .......... .. | %13 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER> )<br>
   * nodeListOptional -> ( PossibleExtensions() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final PossibleExtensions n) {
    R nRes = null;
    // nodeChoice -> ( %00 <EXTENSION_CONC>
    // .......... .. | %01 <EXTENSION_COMPARTMENT>
    // .......... .. | %02 <EXTENSION_PARTICLE>
    // .......... .. | %03 <EXTENSION_TRANS>
    // .......... .. | %04 <EXTENSION_INIT>
    // .......... .. | %05 <EXTENSION_RATE>
    // .......... .. | %06 <EXTENSION_SPECIES>
    // .......... .. | %07 <EXTENSION_GLOBALQ>
    // .......... .. | %08 <EXTENSION_FUNCTION>
    // .......... .. | %09 <EXTENSION_REACTION>
    // .......... .. | %10 <EXTENSION_FLUX>
    // .......... .. | %11 <MY_SPECIAL_EXTENSION>
    // .......... .. | %12 #0 "." #1 <IDENTIFIER>
    // .......... .. | %13 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER> )
    final NodeChoice n0 = n.nodeChoice;
    final NodeChoice n0C = n0;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %00 <EXTENSION_CONC>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %01 <EXTENSION_COMPARTMENT>
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %02 <EXTENSION_PARTICLE>
        nRes = n0CH.accept(this);
        break;
      case 3:
        // %03 <EXTENSION_TRANS>
        nRes = n0CH.accept(this);
        break;
      case 4:
        // %04 <EXTENSION_INIT>
        nRes = n0CH.accept(this);
        break;
      case 5:
        // %05 <EXTENSION_RATE>
        nRes = n0CH.accept(this);
        break;
      case 6:
        // %06 <EXTENSION_SPECIES>
        nRes = n0CH.accept(this);
        break;
      case 7:
        // %07 <EXTENSION_GLOBALQ>
        nRes = n0CH.accept(this);
        break;
      case 8:
        // %08 <EXTENSION_FUNCTION>
        nRes = n0CH.accept(this);
        break;
      case 9:
        // %09 <EXTENSION_REACTION>
        nRes = n0CH.accept(this);
        break;
      case 10:
        // %10 <EXTENSION_FLUX>
        nRes = n0CH.accept(this);
        break;
      case 11:
        // %11 <MY_SPECIAL_EXTENSION>
        nRes = n0CH.accept(this);
        break;
      case 12:
        // %12 #0 "." #1 <IDENTIFIER>
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 "."
        final INode n0CHS012A0 = n0CHS0.elementAt(0);
        nRes = n0CHS012A0.accept(this);
        // #1 <IDENTIFIER>
        final INode n0CHS012A1 = n0CHS0.elementAt(1);
        nRes = n0CHS012A1.accept(this);
        break;
      case 13:
        // %13 #0 <MUTANT_PARENT_SEPARATOR> #1 <IDENTIFIER>
        final NodeSequence n0CHS1 = (NodeSequence) n0CH;
        // #0 <MUTANT_PARENT_SEPARATOR>
        final INode n0CHS113A0 = n0CHS1.elementAt(0);
        nRes = n0CHS113A0.accept(this);
        // #1 <IDENTIFIER>
        final INode n0CHS113A1 = n0CHS1.elementAt(1);
        nRes = n0CHS113A1.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    // nodeListOptional -> ( PossibleExtensions() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        nRes = n1Mi.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Literal} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 <INTEGER_LITERAL><br>
   * .......... .. | %1 <FLOATING_POINT_LITERAL><br>
   * .......... .. | %2 BooleanLiteral()<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Literal n) {
    R nRes = null;
    // nodeChoice -> . %0 <INTEGER_LITERAL>
    // .......... .. | %1 <FLOATING_POINT_LITERAL>
    // .......... .. | %2 BooleanLiteral()
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 <INTEGER_LITERAL>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 <FLOATING_POINT_LITERAL>
        nRes = n0CH.accept(this);
        break;
      case 2:
        // %2 BooleanLiteral()
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link BooleanLiteral} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 <TRUE><br>
   * .......... .. | %1 <FALSE><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final BooleanLiteral n) {
    R nRes = null;
    // nodeChoice -> . %0 <TRUE>
    // .......... .. | %1 <FALSE>
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 <TRUE>
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 <FALSE>
        nRes = n0CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link ArgumentList} node, whose children are the following :
   * <p>
   * nodeChoice -> . %0 MultistateSites_list()<br>
   * .......... .. | %1 #0 AdditiveExpression()<br>
   * .......... .. . .. #1 ( $0 <COMMA> $1 AdditiveExpression() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final ArgumentList n) {
    R nRes = null;
    // nodeChoice -> . %0 MultistateSites_list()
    // .......... .. | %1 #0 AdditiveExpression()
    // .......... .. . .. #1 ( $0 <COMMA> $1 AdditiveExpression() )*
    final NodeChoice n0C = n.nodeChoice;
    final INode n0CH = n0C.choice;
    switch (n0C.which) {
      case 0:
        // %0 MultistateSites_list()
        nRes = n0CH.accept(this);
        break;
      case 1:
        // %1 #0 AdditiveExpression()
        // .. #1 ( $0 <COMMA> $1 AdditiveExpression() )*
        final NodeSequence n0CHS0 = (NodeSequence) n0CH;
        // #0 AdditiveExpression()
        final INode n0CHS01A0 = n0CHS0.elementAt(0);
        nRes = n0CHS01A0.accept(this);
        // #1 ( $0 <COMMA> $1 AdditiveExpression() )*
        final INode n0CHS01A1 = n0CHS0.elementAt(1);
        final NodeListOptional n0CHS01A1T = (NodeListOptional) n0CHS01A1;
        if (n0CHS01A1T.present()) {
          for (int i = 0; i < n0CHS01A1T.size(); i++) {
            final INode n0CHS01A1TMi = n0CHS01A1T.elementAt(i);
            final NodeSequence n0CHS01A1TMiS1 = (NodeSequence) n0CHS01A1TMi;
            // $0 <COMMA>
            final INode n0CHS01A1TMiS1A0 = n0CHS01A1TMiS1.elementAt(0);
            nRes = n0CHS01A1TMiS1A0.accept(this);
            // $1 AdditiveExpression()
            final INode n0CHS01A1TMiS1A1 = n0CHS01A1TMiS1.elementAt(1);
            nRes = n0CHS01A1TMiS1A1.accept(this);
          }
        }
        break;
      default:
        // should not occur !!!
        break;
    }
    return nRes;
  }

  /**
   * Visits a {@link ArgumentList_MultistateSum} node, whose children are the following :
   * <p>
   * name -> Name()<br>
   * nodeOptional -> [ ArgumentList_MultistateSum_Selectors() ]<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final ArgumentList_MultistateSum n) {
    R nRes = null;
    // name -> Name()
    final Name n0 = n.name;
    nRes = n0.accept(this);
    // nodeOptional -> [ ArgumentList_MultistateSum_Selectors() ]
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      nRes = n1.accept(this);
    }
    return nRes;
  }

  /**
   * Visits a {@link ArgumentList_MultistateSum_Selectors} node, whose children are the following :
   * <p>
   * nodeToken -> <SEMICOLON><br>
   * selector -> Selector()<br>
   * nodeListOptional -> ( #0 <SEMICOLON> #1 Selector() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final ArgumentList_MultistateSum_Selectors n) {
    R nRes = null;
    // nodeToken -> <SEMICOLON>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // selector -> Selector()
    final Selector n1 = n.selector;
    nRes = n1.accept(this);
    // nodeListOptional -> ( #0 <SEMICOLON> #1 Selector() )*
    final NodeListOptional n2 = n.nodeListOptional;
    if (n2.present()) {
      for (int i = 0; i < n2.size(); i++) {
        final INode n2Mi = n2.elementAt(i);
        final NodeSequence n2MiS0 = (NodeSequence) n2Mi;
        // #0 <SEMICOLON>
        final INode n2MiS0A0 = n2MiS0.elementAt(0);
        nRes = n2MiS0A0.accept(this);
        // #1 Selector()
        final INode n2MiS0A1 = n2MiS0.elementAt(1);
        nRes = n2MiS0A1.accept(this);
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link Selector} node, whose children are the following :
   * <p>
   * name -> Name()<br>
   * nodeOptional -> [ %0 SiteSelector_postFix()<br>
   * ............ .. | %1 CoeffFunction_postFix() ]<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final Selector n) {
    R nRes = null;
    // name -> Name()
    final Name n0 = n.name;
    nRes = n0.accept(this);
    // nodeOptional -> [ %0 SiteSelector_postFix()
    // ............ .. | %1 CoeffFunction_postFix() ]
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      final NodeChoice n1C = (NodeChoice) n1.node;
      final INode n1CH = n1C.choice;
      switch (n1C.which) {
        case 0:
          // %0 SiteSelector_postFix()
          nRes = n1CH.accept(this);
          break;
        case 1:
          // %1 CoeffFunction_postFix()
          nRes = n1CH.accept(this);
          break;
        default:
          // should not occur !!!
          break;
      }
    }
    return nRes;
  }

  /**
   * Visits a {@link SiteSelector_postFix} node, whose children are the following :
   * <p>
   * nodeToken -> <LBRACE><br>
   * expression -> Expression()<br>
   * nodeOptional -> ( %0 ( #0 <COMMA><br>
   * ............ .. . .. . #1 ( &0 Name()<br>
   * ............ .. . .. . .. | &1 Literal() ) )+<br>
   * ............ .. | %1 ( #0 <COLON> #1 Expression() ) )?<br>
   * nodeToken1 -> <RBRACE><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final SiteSelector_postFix n) {
    R nRes = null;
    // nodeToken -> <LBRACE>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // expression -> Expression()
    final Expression n1 = n.expression;
    nRes = n1.accept(this);
    // nodeOptional -> ( %0 ( #0 <COMMA>
    // ............ .. . .. . #1 ( &0 Name()
    // ............ .. . .. . .. | &1 Literal() ) )+
    // ............ .. | %1 ( #0 <COLON> #1 Expression() ) )?
    final NodeOptional n2 = n.nodeOptional;
    if (n2.present()) {
      final NodeChoice n2C = (NodeChoice) n2.node;
      final INode n2CH = n2C.choice;
      switch (n2C.which) {
        case 0:
          // %0 ( #0 <COMMA>
          // .. . #1 ( &0 Name()
          // .. . .. | &1 Literal() ) )+
          final NodeList n2CHL = (NodeList) n2CH;
          for (int i = 0; i < n2CHL.size(); i++) {
            final INode n2CHLEi = n2CHL.elementAt(i);
            final NodeSequence n2CHLEiS0 = (NodeSequence) n2CHLEi;
            // #0 <COMMA>
            final INode n2CHLEiS0A0 = n2CHLEiS0.elementAt(0);
            nRes = n2CHLEiS0A0.accept(this);
            // #1 ( &0 Name()
            // .. | &1 Literal() )
            final INode n2CHLEiS0A1 = n2CHLEiS0.elementAt(1);
            final NodeChoice n2CHLEiS0A1C = (NodeChoice) n2CHLEiS0A1;
            final INode n2CHLEiS0A1CH = n2CHLEiS0A1C.choice;
            switch (n2CHLEiS0A1C.which) {
              case 0:
                // &0 Name()
                nRes = n2CHLEiS0A1CH.accept(this);
                break;
              case 1:
                // &1 Literal()
                nRes = n2CHLEiS0A1CH.accept(this);
                break;
              default:
                // should not occur !!!
                break;
            }
          }
          break;
        case 1:
          // %1 ( #0 <COLON> #1 Expression() )
          final NodeSequence n2CHS0 = (NodeSequence) n2CH;
          // #0 <COLON>
          final INode n2CHS0A0 = n2CHS0.elementAt(0);
          nRes = n2CHS0A0.accept(this);
          // #1 Expression()
          final INode n2CHS0A1 = n2CHS0.elementAt(1);
          nRes = n2CHS0A1.accept(this);
          break;
        default:
          // should not occur !!!
          break;
      }
    }
    // nodeToken1 -> <RBRACE>
    final NodeToken n3 = n.nodeToken1;
    nRes = n3.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link CoeffFunction_postFix} node, whose children are the following :
   * <p>
   * nodeToken -> <LPAREN><br>
   * nodeOptional -> [ ArgumentList() ]<br>
   * nodeToken1 -> <RPAREN><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final CoeffFunction_postFix n) {
    R nRes = null;
    // nodeToken -> <LPAREN>
    final NodeToken n0 = n.nodeToken;
    nRes = n0.accept(this);
    // nodeOptional -> [ ArgumentList() ]
    final NodeOptional n1 = n.nodeOptional;
    if (n1.present()) {
      nRes = n1.accept(this);
    }
    // nodeToken1 -> <RPAREN>
    final NodeToken n2 = n.nodeToken1;
    nRes = n2.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link MultistateSite} node, whose children are the following :
   * <p>
   * name -> Name()<br>
   * nodeToken -> <LBRACE><br>
   * nodeChoice -> ( %0 Name()<br>
   * .......... .. | %1 Literal() )<br>
   * nodeToken1 -> <RBRACE><br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final MultistateSite n) {
    R nRes = null;
    // name -> Name()
    final Name n0 = n.name;
    nRes = n0.accept(this);
    // nodeToken -> <LBRACE>
    final NodeToken n1 = n.nodeToken;
    nRes = n1.accept(this);
    // nodeChoice -> ( %0 Name()
    // .......... .. | %1 Literal() )
    final NodeChoice n2 = n.nodeChoice;
    final NodeChoice n2C = n2;
    final INode n2CH = n2C.choice;
    switch (n2C.which) {
      case 0:
        // %0 Name()
        nRes = n2CH.accept(this);
        break;
      case 1:
        // %1 Literal()
        nRes = n2CH.accept(this);
        break;
      default:
        // should not occur !!!
        break;
    }
    // nodeToken1 -> <RBRACE>
    final NodeToken n3 = n.nodeToken1;
    nRes = n3.accept(this);
    return nRes;
  }

  /**
   * Visits a {@link MultistateSites_list} node, whose children are the following :
   * <p>
   * multistateSite -> MultistateSite()<br>
   * nodeListOptional -> ( #0 <SEMICOLON> #1 MultistateSite() )*<br>
   *
   * @param n - the node to visit
   * @return the user return information
   */
  public R visit(final MultistateSites_list n) {
    R nRes = null;
    // multistateSite -> MultistateSite()
    final MultistateSite n0 = n.multistateSite;
    nRes = n0.accept(this);
    // nodeListOptional -> ( #0 <SEMICOLON> #1 MultistateSite() )*
    final NodeListOptional n1 = n.nodeListOptional;
    if (n1.present()) {
      for (int i = 0; i < n1.size(); i++) {
        final INode n1Mi = n1.elementAt(i);
        final NodeSequence n1MiS0 = (NodeSequence) n1Mi;
        // #0 <SEMICOLON>
        final INode n1MiS0A0 = n1MiS0.elementAt(0);
        nRes = n1MiS0A0.accept(this);
        // #1 MultistateSite()
        final INode n1MiS0A1 = n1MiS0.elementAt(1);
        nRes = n1MiS0A1.accept(this);
      }
    }
    return nRes;
  }

}
